<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Notes on Distriuted point functions</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../crypto.css" />
  <link rel="stylesheet" href="/code/bootstrap.min.css">
  <script src="/code/jquery.min.js"></script>
  <script src="/code/bootstrap.min.js"></script>


  <ul class="bar">
    <li class="barli"><a class="active" href="/">Home</a></li>
    <li class="barli"><a href="/differentialprivacy/index.html">My Notes</a></li>  
    <li class="barli"><a href="./..">Back</a></li>  
    <!-- <li class="barli"><a href="https://abiswas3.github.io/differentialprivacy.github.io">Notes on Differential Privacy</a></li> -->
  </ul>

  <script src="../../code/es5/tex-chtml.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Notes on Distriuted point functions</h1>
</header>
<div class="container">
<p><strong>Some notation</strong>: <span
class="math inline">\(F\)</span> is always a finite field <span
class="math inline">\(\mathbb{Z}_p\)</span> where <span
class="math inline">\(p\)</span> is a very very large prime. <span
class="math inline">\(\mathbb{G}\)</span> is always some abelian
group.</p>
<h1 id="function-secret-sharing">Function Secret Sharing</h1>
<h2 id="notation-and-prelims">Notation and prelims</h2>
<p>Use same notation as these write-ups. They all copy from one
another.</p>
<ol type="1">
<li><a href="https://eprint.iacr.org/2019/1095.pdf">The latest DPF
paper</a></li>
<li><a href="https://cs.idc.ac.il/~elette/HSS_FSS-Survey.pdf">FSS and
HSS survey</a></li>
</ol>
<h2 id="distributed-point-functions">Distributed Point Functions</h2>
<div class="lemma">
<h4>
Definition
</h4>
<p>Point function <span class="math inline">\(f_{\alpha,\beta}\)</span>
for <span class="math inline">\(\alpha \in \{0, 1\}^n\)</span> and <span
class="math inline">\(\beta \in \mathbb{G}\)</span>,is defined to be the
function <span class="math inline">\(f : \{0,1 \}^n \rightarrow
\mathbb{G}\)</span> such that <span
class="math inline">\(f(\alpha)=\beta\)</span> and <span
class="math inline">\(f(x) = 0\)</span> for <span
class="math inline">\(x \neq \alpha\)</span>. We will sometimes refer to
a point function with <span class="math inline">\(|\beta| = 1\)</span>
(resp., <span class="math inline">\(|\beta| &gt; 1\)</span>) as a
single-bit (resp., multi-bit) point function. A Distributed Point
Function (DPF) is an FSS for the family of all point functions, with the
leakage <span class="math inline">\(Leak(\hat{f}) =
(1^n,\mathbb{G})\)</span>.</p>
</div>
<p><br></p>
<p>The above statement is a formal way of describing the following
pictures:</p>
<p><img src="./pngs/point_functions.jpg" width=95%></img></p>
<p>A distributed point function describes the following idea (note
almost always the <span class="math inline">\(Eval\)</span> will be
additive. Though we only require that it be linear - So shamirs secret
sharing also works instead of additive secret sharing.)</p>
<h2 id="latest-formulation-for-general-dpf">Latest Formulation for
General DPF</h2>
<p>The figure below taken from this <a
href="https://www.youtube.com/watch?v=Zm-MUVve2_w">talk</a> by <a
href="https://scholar.google.com/citations?user=tLjnqu0AAAAJ&amp;hl=en">Elette
Boyle</a>, describes the related work in building efficient protocols
for DPF’s.</p>
<p><img src="./pngs/history.png" width=75%></img></p>
<p>We describe the latest formulation in this section – the full
description can be found in section 3.2 of this <a
href="https://dl.acm.org/doi/10.1145/2976749.2978429">paper</a>. In this
protocol, we <span class="math inline">\(F= \mathbb{Z}_2\)</span>, so
the <span class="math inline">\(+\)</span> operation can be interpreted
as the <span class="math inline">\(XOR\)</span> operation.</p>
<p>Assume we have access to a length doubling PRNG as described below.
They key generation process is as follows:</p>
<ol type="1">
<li>The client samples <span class="math inline">\(s_0\)</span> and
<span class="math inline">\(s_1\)</span> uniformly at random from <span
class="math inline">\(\{ 0, 1\}^{\lambda}\)</span>, where <span
class="math inline">\(\lambda\)</span> is the security parameter. It
sends <span class="math inline">\(s_0\)</span> to server 0 and <span
class="math inline">\(s_1\)</span> to server 1. Additionally it sends
<span class="math inline">\(t_0 \sim \{0,1\}\)</span> to server 0 and
<span class="math inline">\(t_1 = t_0 + 1\)</span> to server 1.</li>
</ol>
<p><img src="./pngs/protocol.png" width="90%"></img></p>
<ol start="2" type="1">
<li><p>It also sends each server a correction word <span
class="math inline">\(CW_{1}\)</span>. The clients follow the protocol
described in the picture above. At this point, each server should have
constructed a tree of with 3 nodes. The root and it’s children.</p></li>
<li><p>For the 2nd level onwards, the client sends the servers one
correcting vector <span class="math inline">\(CW_{i}\)</span> per level
<span class="math inline">\(i\)</span> and follows the protocol
described below</p></li>
</ol>
<p><img src="./pngs/continue.png" width="90%"></img></p>
<h3 id="a-worked-out-toy-example.">A worked out toy example.</h3>
<p><strong>TODO ari: worked out example in code in GoLang</strong> as
that is what Henry Gibbs writes most of his code in. Will be able to
reproduce their work and compare with PRIO.</p>
<h2 id="extractable-dpf-summarised">Extractable DPF (summarised)</h2>
<p>By further dividing the seed in each node to a public part that is
common between two servers and a private part that for each server, the
Poplar paper shows that is nearly impossible for a malicious client to
come up with an input that is non zero at more than 1 location and still
have a common public part. This was done to prevent clients from sending
inputs that are not invalid but are not included in the Subset <span
class="math inline">\(S\)</span>. This does not really matter for the
voting problem as if they are not in <span
class="math inline">\(S\)</span> then those votes won’t count
anyway.</p>
<h2 id="incremental-dpf-summarised">Incremental DPF (summarised)</h2>
<p>The heavy hitters section makes calls to the subset sum problem, thus
there is <span class="math inline">\(\lambda n^2\)</span> communication
complexity. They have a construction that is more efficient and still
uses <span class="math inline">\(\lambda n\)</span> but this is only
needed for private heavy hitters, which I have not read in full
detail.</p>
<p>For specific details see this talk by <a
href="https://www.youtube.com/watch?v=JP9CNjC2iUo&amp;list=PL8Vt-7cSFnw1F7bBFws2kWA-7JVFkqKTy&amp;index=5">Henry
Corrigan Gibbs - part II</a>.</p>
</div>
</div>
<div id="footer">
  “Study hard what interests you the most in the most undisciplined, irreverent and original manner possible.”― Richard Feynmann
</div>
</body>
</html>
