<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Readme</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../../crypto.css" />
  <link rel="stylesheet" href="/code/bootstrap.min.css">
  <script src="/code/jquery.min.js"></script>
  <script src="/code/bootstrap.min.js"></script>


  <ul class="bar">
    <li class="barli"><a class="active" href="/">Home</a></li>
    <li class="barli"><a href="/differentialprivacy/index.html">My Notes</a></li>  
    <li class="barli"><a href="./..">Back</a></li>  
    <!-- <li class="barli"><a href="https://abiswas3.github.io/differentialprivacy.github.io">Notes on Differential Privacy</a></li> -->
  </ul>

  <script src="../../../code/es5/tex-chtml.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<p><strong>Why:</strong>These notes are based on Chapter 4 of [<a
href="https://www.amazon.co.uk/Foundations-Cryptography-v1-Basic-Tools/dp/0521035368"
title="Foundations of Cryptography V1">1</a>]. At the time of writing, I
wanted to understand and re-derive the proofs for Poplar and Prio, so I
could write my own paper.</p>
<h2 id="understanding-zero-knowledge-proofs">Understanding Zero
Knowledge Proofs</h2>
<h2 id="knowledge-vs-information">Knowledge Vs Information</h2>
<p><em>Knowledge is related to computational difficulty, whereas
information is not</em>. Assume that Alice and Bob have access have
access to a public Graph <span class="math inline">\(G\)</span>. Alice
answers questions of the form “Is the graph Eulerian?” or “Is the graph
Hamiltonian?”. From an information-theory point of view, answers to both
questions give Bob 1 bit of information (yes or a no), so the answers
are equivalent.</p>
<p><em>Knowledge relates mainly to publicly known objects,whereas
information relates mainly to objects on which only partial information
is publicly known.</em> Consider the case in which Alice answers each
question by flipping an unbiased coin and telling Bob the outcome. From
an information-theoretic point of view, Bob gets from Alice information
concerning an event. However, we say that Bob gains no knowledge from
Alice, because he could toss coins by himself.</p>
<h2 id="notation">Notation</h2>
<p>Let <span class="math inline">\(A\)</span> and <span
class="math inline">\(B\)</span> be two interactive turing machines
(ITM). Let <span class="math inline">\(\langle A,B \rangle(x)\)</span>
be the random variable representing the local output of <span
class="math inline">\(B\)</span> when interacting with <span
class="math inline">\(A\)</span> on common input <span
class="math inline">\(x\)</span>.</p>
<div class="theorem">
<p><b>The Complexity of an Interactive Machine: </b> We say that an ITM
<span class="math inline">\(A\)</span> has time complexity <span
class="math inline">\(t: \mathbb{N} \rightarrow \mathbb{N}\)</span>, if
for <strong>every</strong> ITM <span class="math inline">\(B\)</span>
and <strong>every</strong> common input string <span
class="math inline">\(x\)</span>, machine <span
class="math inline">\(A\)</span> regardless of its or <span
class="math inline">\(B\)</span>’s random tape; halts in <span
class="math inline">\(t(|x|)\)</span> steps. <span
class="math inline">\(A\)</span> is poly time if there exists a
polynomial <span class="math inline">\(p\)</span> such that <span
class="math inline">\(t=p\)</span>.</p>
</div>
<h3 id="interactive-proof-system">Interactive Proof System</h3>
<div class="theorem">
<p>A pair of ITM’s <span class="math inline">\((P,V)\)</span> is called
an interactive proof system for a language <span
class="math inline">\(L\)</span> if machine <span
class="math inline">\(V\)</span> is polynomial time and the following
two hold:</p>
<ol type="1">
<li><p>Completeness: For every <span class="math inline">\(x \in
L\)</span> and given prover <span class="math inline">\(P\)</span>, we
have <span class="math inline">\(\mathbb{P}[\langle P,V \rangle(x) = 1]
\geq \frac{2}{3}\)</span></p></li>
<li><p>Soundness: For every <span class="math inline">\(x \notin
L\)</span> and <u>and every interactive machine <span
class="math inline">\(B\)</span></u>, we have <span
class="math inline">\(\mathbb{P}[\langle B,V \rangle(x) = 1] \leq
\frac{1}{3}\)</span></p></li>
</ol>
</div>
<h3
id="every-language-in-mathcalnp-has-an-interactive-proof-system">Every
language in <span class="math inline">\(\mathcal{NP}\)</span> has an
interactive proof system</h3>
<p>By definition of <span class="math inline">\(\mathcal{NP}\)</span>
there is a polynomial time verifier that approves provers witness.</p>
<button type="button" class="btn btn-info" data-toggle="collapse" data-target="#blah">
Exercise 2: Only languages in <span
class="math inline">\(\mathcal{NP}\)</span> have interactive proof
systems in which both parties are deterministic
</button>
<div id="blah" class="collapse">

</div>
<p><br></p>
<p>In other words, <span class="math inline">\(\mathcal{NP}\)</span> can
be viewed as a class of interactive proof systems in which the
interaction is unidirectional (i.e., from the prover to the verifier)
and the verifier is deterministic (and never errs)</p>
<p>In general proof systems, this requirement is waived. The
communication is bi-directional and the verifier could be probabilistic.
Such a class is referred to as <span
class="math inline">\(\mathcal{IP}\)</span></p>
<h2 id="example-graph-isomorphism">Example: Graph Isomorphism</h2>
<p>Two graphs <span class="math inline">\(G_1=(V_1, E_1), G_2 = (V_2,
E_2)\)</span> are isomorphic if there exists a 1-1 and onto mapping
<span class="math inline">\(f\)</span> such such that any two vertices
<span class="math inline">\(u\)</span> and <span
class="math inline">\(v\)</span> of <span
class="math inline">\(V_1\)</span> are adjacent in <span
class="math inline">\(G_1\)</span> if and only if <span
class="math inline">\(f(u)\)</span> and <span
class="math inline">\(f(v)\)</span> are adjacent in <span
class="math inline">\(G_2\)</span>.</p>
<p><img src="./pngs/isomorphism.png"><em>Picture from
Wikipedia</em></img></p>
<h3 id="an-interactive-proof-system-for-graph-non-isomorphism">An
Interactive Proof System for Graph Non-Isomorphism</h3>
<p>Watch first 30 min of this <a
href="https://www.youtube.com/watch?v=6MshCKY5bTc&amp;list=PLGkwtcB-DfpzST-medFVvrKhinZisfluC&amp;index=2">lecture
video</a> for better explanation</p>
<p>We want the verifier to accept if two graphs are non-isomorphic and
reject otherwise with correctness and soundness as defined above.
<strong>NOTE</strong>: we need a <strong>honest</strong> prover with
unbounded computation capability to do this. This doesn’t matter, as the
definitions only require the verifier to be poly time.</p>
<p>The proof goes as follows:</p>
<div class="algorithm">
<ol type="1">
<li><p>The verifier samples a bit <span class="math inline">\(\sigma \in
\{1, 2\}\)</span>. It then picks a random permutation <span
class="math inline">\(\pi\)</span> from the set of all random
permutations, and permutes <span class="math inline">\(V_\sigma\)</span>
to get <span class="math inline">\(H = \{ (\pi(u), \pi(v)): (u,v) \in
E_\sigma\}\)</span>.</p></li>
<li><p>The <strong>honest prover</strong> is all powerful, and is able
to figure out if <span class="math inline">\(H\)</span> isomorphic to
<span class="math inline">\(G_1\)</span> or <span
class="math inline">\(G_2\)</span>. Let <span
class="math inline">\(H\)</span> be isomorphic to <span
class="math inline">\(G_b\)</span> where <span class="math inline">\(b
\in \{1, 2\}\)</span>. It then sends <span
class="math inline">\(b\)</span> back to the verifier.</p></li>
<li><p>If <span class="math inline">\(b = \sigma\)</span> then the
verifier accepts.</p></li>
</ol>
</div>
<p><br></p>
<p><strong>Completeness:</strong> If the graphs are non isomorphic, the
<span class="math inline">\(b\)</span> will always be equal to <span
class="math inline">\(\sigma\)</span>. It accepts with no error.</p>
<p><strong>Soundness:</strong> If the graphs are isomorphic, then the
prover will then both <span class="math inline">\(b\)</span>’s are
equally likely and we get accept with probability <span
class="math inline">\(1/2\)</span>. This holds as long as <span
class="math inline">\(b\)</span> is secret (private coin) – but this not
essential as there is a way to convert this into a public coin protocol
with one more round.</p>
<h2 id="zero-knowledge">Zero Knowledge</h2>
<p>Loosely speaking, we say that an interactive proof system <span
class="math inline">\((P, V)\)</span> for a language <span
class="math inline">\(L\)</span> is zero-knowledge if whatever can be
efficiently computed after interacting with <span
class="math inline">\(P\)</span> on input <span class="math inline">\(x
\in L\)</span> can also be efficiently computed from <span
class="math inline">\(x\)</span> (without any interaction).</p>
<p>We stress that this holds with respect to any efficient way of
interacting with <span class="math inline">\(P\)</span>, not necessarily
the way defined by the verifier program <span
class="math inline">\(V\)</span>. Actually, zero-knowledge is a property
of the prescribed prover <span class="math inline">\(P\)</span>. It
captures <span class="math inline">\(P\)</span>’s robustness against
attempts to gain knowledge by interacting with it.</p>
<h3 id="definition-impossible-perfect-zk">Definition: Impossible perfect
ZK</h3>
<div class="theorem">
<p>For a given interactive proof system <span
class="math inline">\(\langle P,V \rangle\)</span> and common input
<span class="math inline">\(x\)</span>, <span
class="math inline">\(P\)</span> is perfectly zero knowledge if for
<strong>every</strong> probabilistic poly time verifier <span
class="math inline">\(V^*\)</span>, there exists an ppt algorithm <span
class="math inline">\(M^*\)</span> such that for ever <span
class="math inline">\(x \in L\)</span> the following random variables
are identically distributed:</p>
<ol type="1">
<li><span class="math inline">\(\langle P,V^* \rangle(x)\)</span>:
Output of interactive verifier.</li>
<li><span class="math inline">\(M^*(x)\)</span>: Just the output of
<span class="math inline">\(M^*\)</span> on x.</li>
</ol>
</div>
<br>
<div class="important">
<p>Machine <span class="math inline">\(M^{*}\)</span> is called a
simulator for the interaction of <span
class="math inline">\(V^*\)</span> with P.</p>
</div>
<p><code>Admittedly, failure to provide a simulation of an interaction with the outside does NOT necessarily mean that this interaction results in some “real gain” (in some intuitive sense). Yet what matters is that any “real gain” can NOT occur whenever we are able to present a simulation.</code></p>
<p>Trivially, any language in <span
class="math inline">\(\mathcal{BPP}\)</span> has a perfect zero
knowledge proof.</p>
<h3 id="definition-relaxed-practical-perfect-zk">Definition: Relaxed
(practical) perfect ZK</h3>
<p>Unfortunately, the above definition is too strict. No one has yet
shown a non trivial case where all the requirements are satisfied. So we
define a relaxation by allowing the simulator to fail to come up with an
answer with probability at most <span
class="math inline">\(\frac{1}{2}\)</span>.</p>
<div class="theorem">
<p>For a given interactive proof system <span
class="math inline">\(\langle P,V \rangle\)</span> and common input
<span class="math inline">\(x\)</span>, <span
class="math inline">\(P\)</span> is perfectly zero knowledge if for
<strong>every</strong> probabilistic poly time verifier <span
class="math inline">\(V^*\)</span>, there exists an ppt algorithm <span
class="math inline">\(M^*\)</span> such that for ever <span
class="math inline">\(x \in L\)</span> the following random conditions
hold:</p>
<ol type="1">
<li>With probability at most <span
class="math inline">\(\frac{1}{2}\)</span> on input <span
class="math inline">\(x\)</span> machine <span
class="math inline">\(M^*\)</span> outputs a special symbol denoted by
<span class="math inline">\(\bot\)</span>.</li>
<li>Let <span class="math inline">\(\mathbb{P}\Big[ m^*(x) = \alpha\Big]
= \mathbb{P}\Big[ M^*(x) = \alpha | M^*(x) \neq \bot\Big]\)</span> for
every <span class="math inline">\(\alpha \in \{ 0, 1\}^*\)</span>. Then
apply perfect zero knowledge on <span
class="math inline">\(m^*(x)\)</span> by requiring the output of <span
class="math inline">\(\langle P,V^* \rangle(x)\)</span> and <span
class="math inline">\(m^*(x)\)</span> be identically distributed.</li>
</ol>
</div>
<br>
<div class="important">
<p>Machine <span class="math inline">\(M^{*}\)</span> is called a
simulator for the interaction of <span
class="math inline">\(V^*\)</span> with P.</p>
</div>
<h2 id="definition-computational-zk">Definition: Computational ZK</h2>
<p>We observe (based on some bits in chapter 3) that for practical
purposes there is no need to be able to “perfectly simulate” the output
of <span class="math inline">\(V^*\)</span> after it interacts with
<span class="math inline">\(P\)</span>. Instead, it suffices to generate
a probability distribution that is computationally indistinguishable
from the output of <span class="math inline">\(V^*\)</span> after it
interacts with <span class="math inline">\(P\)</span>.</p>
<h3 id="computational-indistinguishability">Computational
indistinguishability</h3>
<div class="theorem">
<p>Ensembles <span class="math inline">\(\{ R_x\}_{x \in L}\)</span> and
<span class="math inline">\(\{ S_x\}_{x \in L}\)</span> are
computationally indistinguishable if for <strong>every</strong> ppt
algorithm D and for <strong>every</strong> polynomial, for sufficiently
long <span class="math inline">\(x \in L\)</span>, it holds that</p>
<p><span class="math display">\[\begin{align*}
\Bigg| \mathbb{P}\Big[ D(x, R_x)=1\Big] - \mathbb{P}\Big[ D(x,
S_x)=1\Big]\Bigg| &amp;&lt; \frac{1}{p(|x|)}
\end{align*}\]</span></p>
</div>
<br>
<div class="theorem">
<p>Let <span class="math inline">\((P, V)\)</span> be an interactive
proof system for some language <span class="math inline">\(L\)</span>.
We say that <span class="math inline">\((P, V)\)</span> is
computationally zero knowledge or just simply zero knowledge if for
<strong>every</strong> probabilistic poly time verifier <span
class="math inline">\(V^*\)</span>, there exists a probabilistic ppt
algorithm <span class="math inline">\(M^*\)</span> such that the
following two ensembles are computationally indistinguishable:</p>
<ol type="1">
<li><span class="math inline">\(\{\langle P,V^* \rangle(x)\}_{x \in
L}\)</span>: Output of interactive verifier.</li>
<li><span class="math inline">\(\{M^*(x)\}_{x \in L}\)</span>: Just the
output of <span class="math inline">\(M^*\)</span> on x.</li>
</ol>
</div>
<p><br></p>
<div class="important">
<p>Machine <span class="math inline">\(M^{*}\)</span> is called a
simulator for the interaction of <span
class="math inline">\(V^*\)</span> with P.</p>
</div>
<h2 id="alternate-zk">Alternate: ZK</h2>
<p>An alternative formulation of zero-knowledge considers the verifier’s
view of the inter- action with the prover, rather than only the output
of the verifier after such an interaction. By the “verifier’s view of
the interaction” we mean the entire sequence of the local configurations
of the verifier during an interaction execution) with the prover.</p>
<p>It suffices to consider only the content of the random tape of the
verifier and the sequence of messages that the verifier has received
from the prover during the execution (since the entire sequence of local
configurations and the final output are determined by those
objects).</p>
<div class="theorem">
<p>Let <span class="math inline">\((P, V), L\)</span> and <span
class="math inline">\(V^*\)</span> be as defined above. Denote <span
class="math inline">\(\text{view}^P_{V^*}\)</span> as the random
variable describing the contents of random tape <span
class="math inline">\(V^*\)</span> and the messages <span
class="math inline">\(V^*\)</span> receives from <span
class="math inline">\(P\)</span> during a joint computation on common
input <span class="math inline">\(x\)</span>. We say that <span
class="math inline">\((P,V)\)</span> is ZK if for <strong>every</strong>
ppt interactive verifier <span class="math inline">\(V^*\)</span> there
exists a probabilistic ppt algorithm <span
class="math inline">\(M^*\)</span> such that <span
class="math inline">\(\{\text{view}^P_{V^*}\}_{x \in L}\)</span> and
<span class="math inline">\(\{M^*\}_{x \in L}\)</span> are
computationally indistinguishable.</p>
</div>
<p><br></p>
<p>Computational ZK and View based ZK differ in that one requires the
output of the verifier to be indistinguishable from the simulator output
and the other requires the view. Clearly the output can be computed
using the view using a deterministic poly-time algorithm but the view
cannot always be computed using just the output. Thus the second
definition guarantees the first definition and is usually easier to work
with (<strong>and also seen in most papers</strong>). It can be also
shown that the two definitions are equivalent (because of the
<strong>every</strong> condition in the verifier definition)</p>
<h2 id="almost-perfect-statistical-zero-knowledge">Almost Perfect
(Statistical) Zero Knowledge</h2>
<p>Same as computational ZK definition but uses statistical
difference.</p>
<h1 id="references">References</h1>
<ol type="1">
<li><a
href="https://www.amazon.co.uk/Foundations-Cryptography-v1-Basic-Tools/dp/0521035368">Foundations
of Cryptography V1</a></li>
</ol>
</div>
<div id="footer">
  “Study hard what interests you the most in the most undisciplined, irreverent and original manner possible.”― Richard Feynmann
</div>
</body>
</html>
