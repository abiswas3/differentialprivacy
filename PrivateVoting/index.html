<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Readme</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../blog.css">
  <script src="../code/es5/tex-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!-- This one is used by general blogs on the root level -->
  <link rel="stylesheet" href="/code/bootstrap.min.css">
  <script src="/code/jquery.min.js"></script>
  <script src="/code/bootstrap.min.js"></script>
  
  
  <ul class="bar">
    <li class="barli"><a class="active" href="/">Home</a></li>
    <li class="barli"><a href="/DifferentialPrivacyMain/index.html">Notes</a></li>  
    <li class="barli"><a href="./..">Back</a></li>    
    <!-- <li class="barli"><a href="https://abiswas3.github.io/differentialprivacy.github.io">Notes on Differential Privacy</a></li> -->
  </ul>
</head>
<body>
<div class="container">
<h1 id="differentially-private-secure-voting-protocols">Differentially Private Secure Voting Protocols</h1>
<p><strong>Work in progress</strong></p>
<p><u>Authors:</u> Ari B, Graham C.</p>
<h2 id="the-non-private-protocol">The non private protocol</h2>
<p>There are <span class="math inline">\(M\)</span> candidates in an election and <span class="math inline">\(n\)</span> voters. Each voter is required to vote for at most 1 candidate once once. A central aggregator collects these votes, aggregates them and declares the winner by computing the index of the candidate that received the most votes. Such an election is known as a plurality election.</p>
<p><img src="pngs/notation.png" width="90%"></img> <img src="pngs/non_private_vote.png" width="90%"></img></p>
<h3 id="assumptions">Assumptions</h3>
<p>For this system to work properly, we need to make the following assumptions:</p>
<ol type="1">
<li>The sever or central aggregator is trusted. This implies that they can see the votes for each user and do not use this information maliciously (such as change a users vote or reject an honest users vote).</li>
<li>The central server is reliable and is not prone to breaches i.e. an adversary cannot hack into the central server and obtain information about voters and their preferences.</li>
</ol>
<h3 id="disadvantages">Disadvantages</h3>
<ol type="1">
<li><p>The above system is not differentially private. An adversary could re-run the election with a neighbouring dataset; this would reveal the vote of a voter.</p></li>
<li><p>We need to trust the central aggregator.</p></li>
<li><p>We hope that the central does not get attacked.</p></li>
</ol>
<h2 id="privacy-models">Privacy models</h2>
<p>The rest of this document attempts to relax aforementioned assumptions by dealing with the system disadvantages. Before describing protocols for private voting, we recap 3 different privacy models. Privacy models apply to both clients (voters) and servers.</p>
<ul>
<li><p>Fully Trusted: In this protocol – the central aggregator is fully trusted. We trust them to not get breached, to do the aggregation correctly, to not use voter inputs maliciously. Similarly, we assume voters did not part take in any voter coercion or did not collude with the server.</p></li>
<li><p>Semi Honest Model/Passive Security/Honest but curious: In this model, we require that the voters and the server all follow the specified protocols to the letter. Outside of the protocols, they may use information to their advantage anyway they want.</p></li>
<li><p>Malicious Model: A fraction of servers or clients might behave adversarially in any way they desire. However, we assume malicious agent has is an PPT algorithm.</p></li>
</ul>
<p>Later we will define another trust model which lies between semi honest and malicious models.</p>
<h2 id="resolving-the-dp-issue">Resolving the DP issue</h2>
<h3 id="fully-trusted-model">Fully Trusted model</h3>
<p>Under the fully trusted model, the central server could add Laplace noise with scale <span class="math inline">\(O(\frac{1}{\epsilon})\)</span> and then compute the arg max or sample the winner using the exponential mechanism. Either would guarantee <span class="math inline">\((\epsilon, 0)\)</span> DP.</p>
<h4 id="issues">Issues</h4>
<p>The central server still has to be trusted to act honestly and it can see who voted for whom</p>
<h4 id="communication-complexity">Communication Complexity</h4>
<p>TODO</p>
<h3 id="semi-honest-clients-and-servers">Semi honest clients and servers</h3>
<p>The semi honest model gets away from having to completely trust the central aggregator. Using a combination additive secret sharing and Shamir’s secret sharing we show that, we can still compute the plurality winner and ensure DP. See the <a href="../slides/PassiveSecureVoting.pdf">these slides for a practical algorithm</a> that allows for certain clients dropping out to compute the winner of plurality election.</p>
<p>In this model, the server adds Laplace noise or uses the exponential mechanism to ensure DP.</p>
<h4 id="issues-1">Issues</h4>
<p>While we have prevented the server from seeing the voter inputs, we now need everyone to follow the protocol honestly. This implies even if one client were to send bad input, the entire election is compromised. <strong>So we now need to be able to deal with malicious clients.</strong></p>
<h4 id="communication-complexity-1">Communication Complexity</h4>
<p>TODO</p>
<h3 id="malicious-clients-and-all-semi-honest-servers-or-at-least-1-semi-honest-server">Malicious clients and <strong>all</strong> semi-honest servers (or at least 1 semi honest server)</h3>
<p>Under this model, we do not put any restrictions on the clients. They can be well behaved or malicious. Instead of having 1 central aggregator, we have <span class="math inline">\(K\)</span> aggregators that work together. Under this model we give the following guarantees:</p>
<ul>
<li>If <strong>all</strong> servers are honest we can detect a malicious client (with very high probability) and prevent them from participating in the elections.</li>
<li>If <strong>all</strong> servers are honest we can get <span class="math inline">\((\epsilon, \delta)\)</span> differential privacy via infinitely divisible noise mechanisms.</li>
<li>If at least 1 server is semi honest and the remaining <span class="math inline">\(K-1\)</span> servers are colluding and dishonest, we cannot run an election but every honest voter’s privacy is preserved i.e. the bad servers cannot learn anything about the voters vote beyond random guessing even when given unlimited computation power.</li>
</ul>
<p>See the following notes for the details of how these protocols work: <a href="../Crypto/SNIPs/">Notes</a></p>
<div class="important">
<p>It is not immediately clear to me if the one honest server in PRIO is able to detect that the other servers are malicious. I need to have re-derive the protocol and have another think. My intuition is – it cannot, but POPLAR can so I guess it doesn’t matter too much.</p>
</div>
<h4 id="how-is-poplar-better-than-prio">How is Poplar better than PRIO?</h4>
<h4 id="comments">Comments</h4>
<ol type="1">
<li><p>Protection against a complete set of malicious servers seems unreasonable, unless we assume that all voters can communicate with each other through peer-to-peer encrypted channels.</p></li>
<li><p>If we are willing to assume that all the servers are honest and trusted, then we get all the nice properties we desire – input privacy and output DP.</p></li>
</ol>
<h3 id="an-new-privacy-model-gossipy-servers">An new privacy model: Gossipy Servers</h3>
<div class="important">
<p>There could a formal term for this model, I am not sure. I made this is up so we should discuss this. I am not sure if this is practical – but this is model prevents central noise addition, so we can use distributed DP.</p>
</div>
<p>We assume that servers are semi-honest i.e. they follow the protocols as required. For correctness of protocol we will require all the servers are semi honest and for privacy we will require at least 1 server is semi honest. Thus far this gives the same level of security as the above section. We add to this set of assumptions another constraint. We assume that at least one of the servers is gossipy and not properly implemented. They are subject to data breaches, spy-wares or and man in the middle attacks. See figure below for an illustration.</p>
<p><img src="pngs/gossip.png" width="90%"></img></p>
<ol type="1">
<li><p>The yellow adversary can be modelled as a malicious client, so there is no extra work. If we use Poplar, one of the honest servers will let the honest client know that one of the servers has been corrupted. As the clients use secret sharing, their privacy is not compromised in any meaningful way. The adversary just sees random values.</p></li>
<li><p>The red adversary is dangerous. Their presence implies, the server cannot be trusted to add calibrated noise. The servers could add 0 noise, ensuring the final aggregate is not differentially private, thereby learning about the clients via re-running the mechanism on a neighbouring dataset. Now the onus of adding noise is on the client through a local randomiser. <strong>But this means, the server checks for malicious clients are no longer valid</strong></p></li>
</ol>
<h3 id="why-do-the-current-distributed-privacy-methods-not-work">Why do the current distributed privacy methods not work</h3>
<ol type="1">
<li><p>One solution is Randomised Response (Local Privacy). The authors of PRIO make a case for why this is not that great of idea. For one the error scales <span class="math inline">\(O(\frac{1}{\sqrt{n}})\)</span>. Furthermore, to be able to reconstruct meaningful estimates, the probability of flipping their true value to a random value <span class="math inline">\(p\)</span> needs to be really small. To illustrate why randomised response is not efficient in such a scenario, we quote the PRIO paper, <code>every bit that each phone transmits leaks some private user information to the vendor. In particular, when p = 0.1 the vendor has a good chance of seeing the correct (unflipped) user response. Increasing the noise level p decreases this leakage, but adding more noise also decreases the accuracy of the vendor’s final estimate. As an example, assume that the vendor collects randomized responses from one million phones using p = 0.49, and that 1% of phones have the sensitive app installed. Even with such a large number of responses, the vendor will incorrectly conclude that no phones have the app installed roughly one third of the time.</code></p></li>
<li><p><strong>Additive noise mechanisms: </strong> <a href="../DifferentialPrivacyMain/PrivateMeanEstimation/">A new line of work</a> shows that if the clients have more than 1 bit to communicate with servers, we can get near constant error. There are two issues with these methods, (1) they need the number of clients <span class="math inline">\(n\)</span> to be very large. (2) There is no efficient way to distinguish between the unlucky honest client and the malicious client. Consider the following example, where the local randomiser requires each client add <span class="math inline">\(Bernoulli(p)\)</span> noise to each of their input coordinates. A dishonest voter, could add no noise and send a vector of all 1’s. Technically this a legal vote and our SNIPs checking protocol would not block this, however the final de-biasing algorithm will be incorrect with high probability.</p></li>
</ol>
<div class="lemma">
<h4>
OPEN PROBLEM:
</h4>
<p>Can we come up with a distributed DP algorithm with “good” accuracy guarantees but where we can also detect ballot stuffing.</p>
</div>
<h2 id="references">References</h2>
</div>
<div id="footer">
  “Study hard what interests you the most in the most undisciplined,
  irreverent and original manner possible.”― Richard Feynmann
</div>
</body>
</html>
